<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Patent主题生成的NewDesign · LanguaLaw</title><meta name="description" content="Patent主题生成的NewDesign - XiangY"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/Langua.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="LanguaLaw"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/Langua.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/6307886646" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Langua666" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Patent主题生成的NewDesign</h1><div class="post-info">2018年3月3日</div><div class="post-content"><p>调查之后，发现Cpp实现、通过NLP方法处理Patent文件的自动生产，是很难通过一己之力实现，以目前的效率和时间条件都难以达到这一个目标。<br>特别是自己写一个专利文件的生成框架，目前还未有那一计划。<br>主题生成的记录与自动生成主题实现：</p>
<pre><code>import  itertools

fa = []
fb = []
fn = []

sub = &apos;Subject.txt&apos;  #同级目录下的txt文件
fea = &apos;Features.txt&apos;
new = &apos;NewDesign.txt&apos;

ta = open(sub)  
tb = open(fea)
tn = open(new,&apos;r+&apos;) #r+读写模式

fa = ta.readlines()
for i in range( 0,len(fa)-1): 
fa[i] = fa[i][:-1]  #去除list中str末尾的\n
print (fa[i])

fb = tb.readlines()
for i in range( 0,len(fb)-1):
fb[i] = fb[i][:-1]
print (fb[i])

newf = []
newf = list(itertools.product(fa,fb))
print (newf)

for i in range( 0,len(newf)):
#print (newf[i])
#for j in range(0,len(newf[i])):
#print (newf[i][j])
print (&quot;能够&quot; + str(newf[i][0]) + &quot;的&quot; + str(newf[i][1]))
tn.writelines(  &quot;能够&quot; + str(newf[i][0]) + &quot;的&quot; + str(newf[i][1]) +&apos;\n&apos;)

tn.close()
#print (len(newf))
</code></pre><p>算作提示自己思维的一个小工具。</p>
<p>参考：朱松纯  浅谈人工智能：现状、任务、构架与统一<br><a href="http://mp.weixin.qq.com/s/3sKfJnPayDCCosKVP3Jz8Q" title="朱松纯  浅谈人工智能：现状、任务、构架与统一" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/3sKfJnPayDCCosKVP3Jz8Q</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/03/hello-world/" class="prev">上一篇</a><a href="/2018/03/03/02が 和 は 的用法/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://yoursite.com">XiangY</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>